export interface CrackpotItem {
  title: string;
  content: string;
  details: string; // for expandable sections
}

export const crackpotItems: CrackpotItem[] = [
  {
    title: " Mind: The Time-Travelling Entity",
    content: "Can the brain â€” with memory and prediction â€” be considered a time-travelling mechanism?",
    details: `
    <p> The classical notion of mindâ€“body dualism â€” that the mind exists independently of the body â€” has long been challenged. Modern neuroscience reveals that what we experience as â€œmindâ€ is deeply rooted in the structure of the brain itself. </p> <p> Damage to specific regions of the brain â€” like the frontal lobe or hippocampus â€” alters personality, memory, and identity. The â€œselfâ€ is not a separate soul; itâ€™s emergent from neural circuitry. </p> <p> Yet this neural machine isnâ€™t bound to the present. It recalls the past through memory, and projects possible futures through imagination and predictive modeling. These temporal leaps allow the mind to simulate timelines far beyond the now. </p> <p> In that sense, the brain behaves like a subjective time machine â€” folding moments into memory, extending seconds into thought, and leaping across experience in nonlinear ways. </p>
    `
  },
  {
    title: "The Act of Computing â€” and Computing Machines",
    content: "What if computation is nothing but nature seeking balance?",
    details: `
   <p> What is computing, really?</p> <p> At its heart, computing is anything that produces an output from a given set of inputs. But I like to interpret it more intuitively: computing is the act of creating balance â€” or reaching a point of stability â€” from an imbalanced or biased state. In the physical world, most machines behave this way. You apply a bias â€” a voltage, a force, a torsion â€” and the system responds by adjusting itself, eventually stabilizing at an outcome. The accuracy of this outcome depends on how intentionally we introduce that imbalance, and how well we understand the framework the system operates within.</p> <p> âš™ï¸ Our Frameworks Define the Problem</p> <p> We build models â€” theoretical frameworks â€” to understand the physical systems we compute with. The strength and validity of these frameworks determine how complex our computational problems feel. Take something simple: multiplication. You have a table for single-digit numbers â€” so you extend it to multiply bigger ones. In this model, the computer is just a slave. The mind behind the computation is still yours. Itâ€™s deterministic. But as we move into harder territory, problems begin to fall into two fascinating categories: </p> <p>ğŸ§® 1. The Problem of Big Numbers </p> <p>Take RSA cryptography. At its core, itâ€™s just multiplying two large prime numbers â€” something a schoolkid could conceptually do. Yet it becomes intractable at large scale. Why? Not because we donâ€™t understand multiplication â€” but because the numbers are enormous, and our systems werenâ€™t built for that kind of weight. </p> <p>ğŸ² 2. The Problem of Uncertainty </p> <p>Some problems lack a deterministic model. We canâ€™t compute an exact result â€” only the best chance of one. These are the kinds of problems where classical machines struggle, because they're too obedient. </p> <p>âš›ï¸ Why Quantum Computing Is Soâ€¦ Different</p> <p> Hereâ€™s where quantum machines start to feel revolutionary â€” even philosophical. </p> <p>ğŸŒŒ 1. Probability as a Feature</p> <p> In uncertain problems, obedient machines fail us. We need machines that exhibit free will â€” or at least the illusion of it. Quantum particles are inherently probabilistic. Theyâ€™re not guessing. They are the probability. So when we evaluate fuzzy models, quantum machines become natural solvers, not brute-force followers. This reminds me of the Lagrangian model in physics: The particle takes the path that minimizes total action â€” the path of least effort. Is this not computation too? Is the universe just constantly computing its own least-action path? </p> <p>âŒ› 2. Time â€” The Chaotic Culprit </p> <p> In relativity, time isnâ€™t straight. It stretches, bends, loops. Yet we define computational complexity as the number of time-steps a process needs. What if there were a way to bypass time? To find a wormhole for solutions, not through brute force but through natureâ€™s shortcuts? Classical machines canâ€™t do that. But quantum ones? Maybe. Just maybe.
    `
  }
];
